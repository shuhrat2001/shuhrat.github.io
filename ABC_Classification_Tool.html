<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generalized Slotting Strategy Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(45deg, #4f46e5, #7c3aed);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            padding: 30px;
        }

        .control-panel {
            background: rgba(79, 70, 229, 0.05);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            border: 2px solid rgba(79, 70, 229, 0.1);
        }

        .control-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-input-btn {
            background: linear-gradient(45deg, #4f46e5, #7c3aed);
            color: white;
            padding: 12px 24px;
            border-radius: 10px;
            cursor: pointer;
            border: none;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(79, 70, 229, 0.3);
        }

        .file-input-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(79, 70, 229, 0.4);
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .input-group label {
            font-weight: 600;
            color: #374151;
            font-size: 14px;
        }

        .input-group input, .input-group select {
            padding: 10px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .btn {
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
        }

        .btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .results-section {
            display: none;
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .grid-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            overflow: auto;
        }

        .grid {
            display: inline-block;
            border-collapse: collapse;
            font-family: monospace;
            font-size: 12px;
        }

        .grid td {
            width: 60px;
            height: 60px;
            border: 1px solid #ddd;
            text-align: center;
            vertical-align: middle;
            position: relative;
            transition: all 0.3s ease;
        }

        .grid td:hover {
            transform: scale(1.05);
            z-index: 10;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .sku-a { background: linear-gradient(135deg, #fee2e2, #fca5a5); }
        .sku-b { background: linear-gradient(135deg, #fef3c7, #fbbf24); }
        .sku-c { background: linear-gradient(135deg, #d1fae5, #6ee7b7); }
        .dock { background: linear-gradient(135deg, #dbeafe, #60a5fa); font-weight: bold; }
        .obstacle { background: linear-gradient(135deg, #f3f4f6, #9ca3af); }

        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .stats-card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .stats-card h3 {
            color: #374151;
            margin-bottom: 15px;
            text-align: center;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f3f4f6;
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .chart-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .file-info {
            background: rgba(16, 185, 129, 0.1);
            border: 2px solid rgba(16, 185, 129, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            color: #065f46;
        }

        .error {
            background: rgba(239, 68, 68, 0.1);
            border: 2px solid rgba(239, 68, 68, 0.2);
            border-radius: 10px;
            padding: 15px;
            color: #991b1b;
            margin: 10px 0;
        }

        .download-section {
            text-align: center;
            margin: 20px 0;
        }

        .download-btn {
            background: linear-gradient(45deg, #8b5cf6, #a855f7);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.3);
            margin: 0 10px;
        }

        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(139, 92, 246, 0.4);
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #4f46e5, #7c3aed);
            width: 0%;
            transition: width 0.3s ease;
        }

        @media (max-width: 768px) {
            .control-row {
                flex-direction: column;
                align-items: stretch;
            }
            
            .stats-container {
                grid-template-columns: 1fr;
            }
            
            .grid td {
                width: 40px;
                height: 40px;
                font-size: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè≠ Generalized Slotting Strategy Tool</h1>
            <p>Optimize warehouse SKU placement for maximum picking efficiency</p>
        </div>

        <div class="main-content">
            <div class="control-panel">
                <div class="control-row">
                    <div class="file-input-wrapper">
                        <input type="file" id="csvFile" accept=".csv,.xlsx,.xls,.txt" />
                        <label for="csvFile" class="file-input-btn">üìÅ Choose File (CSV, Excel, TXT)</label>
                    </div>
                    <div id="fileInfo"></div>
                </div>

                <div class="control-row">
                    <div class="input-group">
                        <label for="dockRow">Dock Row:</label>
                        <input type="number" id="dockRow" value="0" min="0">
                    </div>
                    <div class="input-group">
                        <label for="dockCol">Dock Column:</label>
                        <input type="number" id="dockCol" value="0" min="0">
                    </div>
                    <div class="input-group">
                        <label for="obstacles">Obstacles (row,col;row,col):</label>
                        <input type="text" id="obstacles" placeholder="e.g., 1,1;2,3">
                    </div>
                </div>

                <div class="control-row">
                    <div class="input-group">
                        <label for="classA">Class A %:</label>
                        <input type="number" id="classA" value="20" min="1" max="100">
                    </div>
                    <div class="input-group">
                        <label for="classB">Class B %:</label>
                        <input type="number" id="classB" value="30" min="1" max="100">
                    </div>
                    <div class="input-group">
                        <label for="classC">Class C %:</label>
                        <input type="number" id="classC" value="50" min="1" max="100" readonly>
                    </div>
                </div>

                <div class="control-row">
                    <div class="input-group">
                        <label for="strategy">Slotting Strategy:</label>
                        <select id="strategy">
                            <option value="closest_first">Closest to Dock First</option>
                            <option value="distance_based">Distance-Based Optimization</option>
                            <option value="zone_based">Zone-Based Assignment</option>
                        </select>
                    </div>
                    <button id="processBtn" class="btn" disabled>üöÄ Process & Optimize</button>
                </div>

                <div class="progress-bar" style="display: none;">
                    <div class="progress-fill"></div>
                </div>
            </div>

            <div id="results" class="results-section">
                <div class="stats-container">
                    <div class="stats-card">
                        <h3>üìä Grid Statistics</h3>
                        <div id="gridStats"></div>
                    </div>
                    <div class="stats-card">
                        <h3>üìà SKU Distribution</h3>
                        <div id="skuStats"></div>
                    </div>
                    <div class="stats-card">
                        <h3>‚ö° Optimization Results</h3>
                        <div id="optimizationStats"></div>
                    </div>
                </div>

                <div class="chart-container">
                    <h3>üìä Pareto Analysis</h3>
                    <canvas id="paretoChart" width="400" height="200"></canvas>
                </div>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color sku-a"></div>
                        <span>Class A (High Frequency)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color sku-b"></div>
                        <span>Class B (Medium Frequency)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color sku-c"></div>
                        <span>Class C (Low Frequency)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color dock"></div>
                        <span>Dock Location</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color obstacle"></div>
                        <span>Obstacle</span>
                    </div>
                </div>

                <div class="grid-container">
                    <h3>üè≠ Original Frequency Grid</h3>
                    <div id="originalGrid"></div>
                </div>

                <div class="grid-container">
                    <h3>üéØ Optimized SKU Layout</h3>
                    <div id="optimizedGrid"></div>
                </div>

                <div class="download-section">
                    <button id="downloadCSV" class="download-btn">üì• Download Optimized Layout CSV</button>
                    <button id="downloadReport" class="download-btn">üìã Download Analysis Report</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        class SlottingOptimizer {
            constructor() {
                this.originalData = null;
                this.skuData = [];
                this.optimizedLayout = null;
                this.dockPosition = { row: 0, col: 0 };
                this.obstacles = [];
                this.abcPercentages = { A: 20, B: 30, C: 50 };
                this.strategy = 'closest_first';
                
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                document.getElementById('csvFile').addEventListener('change', (e) => this.handleFileSelect(e));
                document.getElementById('processBtn').addEventListener('click', () => this.processData());
                document.getElementById('downloadCSV').addEventListener('click', () => this.downloadCSV());
                document.getElementById('downloadReport').addEventListener('click', () => this.downloadReport());
                
                // Auto-calculate Class C percentage
                ['classA', 'classB'].forEach(id => {
                    document.getElementById(id).addEventListener('input', this.updateClassC.bind(this));
                });
            }

            updateClassC() {
                const classA = parseInt(document.getElementById('classA').value) || 0;
                const classB = parseInt(document.getElementById('classB').value) || 0;
                const classC = Math.max(0, 100 - classA - classB);
                document.getElementById('classC').value = classC;
            }

            handleFileSelect(event) {
                const file = event.target.files[0];
                if (!file) return;

                const fileInfo = document.getElementById('fileInfo');
                fileInfo.innerHTML = `<div class="file-info">üìÑ Selected: ${file.name} (${(file.size/1024).toFixed(1)} KB)</div>`;

                const fileExtension = file.name.split('.').pop().toLowerCase();
                
                if (fileExtension === 'csv' || fileExtension === 'txt') {
                    // Handle CSV/TXT files
                    Papa.parse(file, {
                        complete: (results) => {
                            this.originalData = results.data;
                            this.validateAndProcessCSV();
                        },
                        header: false,
                        dynamicTyping: true,
                        skipEmptyLines: true
                    });
                } else if (fileExtension === 'xlsx' || fileExtension === 'xls') {
                    // Handle Excel files
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = new Uint8Array(e.target.result);
                            const workbook = XLSX.read(data, { type: 'array' });
                            
                            // Get the first sheet
                            const firstSheetName = workbook.SheetNames[0];
                            const worksheet = workbook.Sheets[firstSheetName];
                            
                            // Convert to array of arrays
                            const jsonData = XLSX.utils.sheet_to_json(worksheet, { 
                                header: 1, 
                                defval: null,
                                raw: false
                            });
                            
                            this.originalData = jsonData;
                            this.validateAndProcessCSV();
                            
                        } catch (error) {
                            this.showMessage(`‚ùå Error reading Excel file: ${error.message}`, 'error');
                        }
                    };
                    reader.onerror = () => {
                        this.showMessage('‚ùå Error reading file', 'error');
                    };
                    reader.readAsArrayBuffer(file);
                } else {
                    this.showMessage('‚ùå Unsupported file format. Please use CSV, Excel (.xlsx, .xls), or TXT files.', 'error');
                }
            }

            validateAndProcessCSV() {
                try {
                    if (!this.originalData || this.originalData.length === 0) {
                        throw new Error('File is empty or contains no valid data');
                    }

                    // Remove any completely empty rows
                    this.originalData = this.originalData.filter(row => 
                        row && row.some(cell => cell !== null && cell !== undefined && cell !== '' && cell !== 0)
                    );

                    if (this.originalData.length === 0) {
                        throw new Error('File contains no valid data rows');
                    }

                    // Find the maximum row length to normalize the grid
                    const maxCols = Math.max(...this.originalData.map(row => row ? row.length : 0));
                    
                    // Normalize all rows to have the same length and convert to numbers
                    this.originalData = this.originalData.map(row => {
                        if (!row) row = [];
                        
                        // Pad row to max length and convert to numbers
                        const normalizedRow = [];
                        for (let i = 0; i < maxCols; i++) {
                            let value = row[i];
                            
                            // Handle different data types
                            if (value === null || value === undefined || value === '') {
                                value = 0; // Default empty cells to 0
                            } else if (typeof value === 'string') {
                                // Try to parse as number
                                const parsed = parseFloat(value.replace(/[^\d.-]/g, ''));
                                value = isNaN(parsed) ? 0 : Math.max(0, parsed);
                            } else if (typeof value === 'number') {
                                value = isNaN(value) ? 0 : Math.max(0, value);
                            } else {
                                value = 0;
                            }
                            
                            normalizedRow.push(value);
                        }
                        return normalizedRow;
                    });

                    // Validate we have at least some non-zero values
                    const hasValidData = this.originalData.some(row => 
                        row.some(cell => cell > 0)
                    );

                    if (!hasValidData) {
                        throw new Error('File contains no positive frequency values');
                    }

                    document.getElementById('processBtn').disabled = false;
                    this.showMessage(`‚úÖ File loaded successfully! Grid size: ${this.originalData.length} √ó ${this.originalData[0].length}`, 'success');
                    
                } catch (error) {
                    this.showMessage(`‚ùå Error: ${error.message}`, 'error');
                    document.getElementById('processBtn').disabled = true;
                }
            }

            showMessage(message, type = 'info') {
                const fileInfo = document.getElementById('fileInfo');
                const className = type === 'error' ? 'error' : 'file-info';
                fileInfo.innerHTML = `<div class="${className}">${message}</div>`;
            }

            processData() {
                if (!this.originalData) return;

                this.showProgress(10);
                
                // Get parameters
                this.dockPosition = {
                    row: parseInt(document.getElementById('dockRow').value) || 0,
                    col: parseInt(document.getElementById('dockCol').value) || 0
                };
                
                this.obstacles = this.parseObstacles(document.getElementById('obstacles').value);
                
                this.abcPercentages = {
                    A: parseInt(document.getElementById('classA').value) || 20,
                    B: parseInt(document.getElementById('classB').value) || 30,
                    C: parseInt(document.getElementById('classC').value) || 50
                };
                
                this.strategy = document.getElementById('strategy').value;

                this.showProgress(30);

                // Process data
                this.flattenGridToSKUs();
                this.showProgress(50);
                
                this.conductParetoAnalysis();
                this.showProgress(70);
                
                this.calculateDistancesFromDock();
                this.showProgress(80);
                
                this.assignSKUsToSlots();
                this.showProgress(90);
                
                this.displayResults();
                this.showProgress(100);
                
                setTimeout(() => {
                    document.querySelector('.progress-bar').style.display = 'none';
                }, 1000);
            }

            showProgress(percent) {
                const progressBar = document.querySelector('.progress-bar');
                const progressFill = document.querySelector('.progress-fill');
                progressBar.style.display = 'block';
                progressFill.style.width = percent + '%';
            }

            parseObstacles(obstacleString) {
                if (!obstacleString.trim()) return [];
                
                return obstacleString.split(';').map(pair => {
                    const [row, col] = pair.split(',').map(n => parseInt(n.trim()));
                    return { row, col };
                }).filter(obs => !isNaN(obs.row) && !isNaN(obs.col));
            }

            flattenGridToSKUs() {
                this.skuData = [];
                let skuId = 0;
                
                for (let row = 0; row < this.originalData.length; row++) {
                    for (let col = 0; col < this.originalData[row].length; col++) {
                        this.skuData.push({
                            id: `SKU${skuId}`,
                            originalRow: row,
                            originalCol: col,
                            frequency: this.originalData[row][col],
                            distance: 0,
                            abcClass: '',
                            assignedRow: -1,
                            assignedCol: -1
                        });
                        skuId++;
                    }
                }
            }

            conductParetoAnalysis() {
                // Sort by frequency descending
                this.skuData.sort((a, b) => b.frequency - a.frequency);
                
                // Calculate total picks and cumulative percentages
                const totalPicks = this.skuData.reduce((sum, sku) => sum + sku.frequency, 0);
                let cumulativeFreq = 0;
                
                this.skuData.forEach(sku => {
                    cumulativeFreq += sku.frequency;
                    sku.cumulativePercentage = (cumulativeFreq / totalPicks) * 100;
                });
                
                // Assign ABC classes
                this.skuData.forEach((sku, index) => {
                    const percentile = ((index + 1) / this.skuData.length) * 100;
                    
                    if (percentile <= this.abcPercentages.A) {
                        sku.abcClass = 'A';
                    } else if (percentile <= this.abcPercentages.A + this.abcPercentages.B) {
                        sku.abcClass = 'B';
                    } else {
                        sku.abcClass = 'C';
                    }
                });
            }

            calculateDistancesFromDock() {
                this.skuData.forEach(sku => {
                    sku.distance = Math.abs(sku.originalRow - this.dockPosition.row) + 
                                  Math.abs(sku.originalCol - this.dockPosition.col);
                });
            }

            assignSKUsToSlots() {
                const rows = this.originalData.length;
                const cols = this.originalData[0].length;
                
                // Create available positions
                let availablePositions = [];
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        // Skip dock and obstacles
                        if ((row === this.dockPosition.row && col === this.dockPosition.col) ||
                            this.obstacles.some(obs => obs.row === row && obs.col === col)) {
                            continue;
                        }
                        
                        const distance = Math.abs(row - this.dockPosition.row) + 
                                       Math.abs(col - this.dockPosition.col);
                        availablePositions.push({ row, col, distance });
                    }
                }
                
                // Sort positions by distance from dock
                availablePositions.sort((a, b) => a.distance - b.distance);
                
                // Apply slotting strategy
                this.applySlottingStrategy(availablePositions);
                
                // Create optimized layout grid
                this.createOptimizedLayout(rows, cols);
            }

            applySlottingStrategy(availablePositions) {
                // Separate SKUs by class
                const classA = this.skuData.filter(sku => sku.abcClass === 'A');
                const classB = this.skuData.filter(sku => sku.abcClass === 'B');
                const classC = this.skuData.filter(sku => sku.abcClass === 'C');
                
                let positionIndex = 0;
                
                // Assign Class A items to closest positions
                classA.forEach(sku => {
                    if (positionIndex < availablePositions.length) {
                        const pos = availablePositions[positionIndex];
                        sku.assignedRow = pos.row;
                        sku.assignedCol = pos.col;
                        positionIndex++;
                    }
                });
                
                // Assign Class B items
                classB.forEach(sku => {
                    if (positionIndex < availablePositions.length) {
                        const pos = availablePositions[positionIndex];
                        sku.assignedRow = pos.row;
                        sku.assignedCol = pos.col;
                        positionIndex++;
                    }
                });
                
                // Assign Class C items
                classC.forEach(sku => {
                    if (positionIndex < availablePositions.length) {
                        const pos = availablePositions[positionIndex];
                        sku.assignedRow = pos.row;
                        sku.assignedCol = pos.col;
                        positionIndex++;
                    }
                });
            }

            createOptimizedLayout(rows, cols) {
                this.optimizedLayout = Array(rows).fill().map(() => Array(cols).fill(null));
                
                // Place SKUs in optimized positions
                this.skuData.forEach(sku => {
                    if (sku.assignedRow >= 0 && sku.assignedCol >= 0) {
                        this.optimizedLayout[sku.assignedRow][sku.assignedCol] = sku;
                    }
                });
                
                // Mark dock and obstacles
                this.optimizedLayout[this.dockPosition.row][this.dockPosition.col] = 'DOCK';
                this.obstacles.forEach(obs => {
                    if (obs.row < rows && obs.col < cols) {
                        this.optimizedLayout[obs.row][obs.col] = 'OBSTACLE';
                    }
                });
            }

            displayResults() {
                this.displayGridStatistics();
                this.displaySKUDistribution();
                this.displayOptimizationResults();
                this.displayParetoChart();
                this.displayGrids();
                
                document.getElementById('results').style.display = 'block';
            }

            displayGridStatistics() {
                const stats = document.getElementById('gridStats');
                const totalSKUs = this.skuData.length;
                const totalPicks = this.skuData.reduce((sum, sku) => sum + sku.frequency, 0);
                const avgFreq = (totalPicks / totalSKUs).toFixed(2);
                
                stats.innerHTML = `
                    <div class="stat-item"><span>Grid Size:</span><span>${this.originalData.length} √ó ${this.originalData[0].length}</span></div>
                    <div class="stat-item"><span>Total SKUs:</span><span>${totalSKUs}</span></div>
                    <div class="stat-item"><span>Total Picks:</span><span>${totalPicks.toLocaleString()}</span></div>
                    <div class="stat-item"><span>Average Frequency:</span><span>${avgFreq}</span></div>
                    <div class="stat-item"><span>Dock Position:</span><span>(${this.dockPosition.row}, ${this.dockPosition.col})</span></div>
                    <div class="stat-item"><span>Obstacles:</span><span>${this.obstacles.length}</span></div>
                `;
            }

           displaySKUDistribution() {
    const stats = document.getElementById('skuStats');
    const classA = this.skuData.filter(sku => sku.abcClass === 'A').length;
    const classB = this.skuData.filter(sku => sku.abcClass === 'B').length;
    const classC = this.skuData.filter(sku => sku.abcClass === 'C').length;
    
    const classAFreq = this.skuData.filter(sku => sku.abcClass === 'A')
        .reduce((sum, sku) => sum + sku.frequency, 0);
    const classBFreq = this.skuData.filter(sku => sku.abcClass === 'B')
        .reduce((sum, sku) => sum + sku.frequency, 0);
    const classCFreq = this.skuData.filter(sku => sku.abcClass === 'C')
        .reduce((sum, sku) => sum + sku.frequency, 0);
    
    stats.innerHTML = `
        <div class="stat-item"><span>Class A SKUs:</span><span>${classA} (${((classA/this.skuData.length)*100).toFixed(1)}%)</span></div>
        <div class="stat-item"><span>Class B SKUs:</span><span>${classB} (${((classB/this.skuData.length)*100).toFixed(1)}%)</span></div>
        <div class="stat-item"><span>Class C SKUs:</span><span>${classC} (${((classC/this.skuData.length)*100).toFixed(1)}%)</span></div>
        <div class="stat-item"><span>Class A Picks:</span><span>${classAFreq.toLocaleString()}</span></div>
        <div class="stat-item"><span>Class B Picks:</span><span>${classBFreq.toLocaleString()}</span></div>
        <div class="stat-item"><span>Class C Picks:</span><span>${classCFreq.toLocaleString()}</span></div>
    `;
}
            // Add this method to your SlottingOptimizer class, right after displaySKUDistribution()

displayOptimizationResults() {
    const stats = document.getElementById('optimizationStats');
    
    // Calculate weighted distance savings
    const totalOriginalDistance = this.skuData.reduce((sum, sku) => {
        const originalDistance = Math.abs(sku.originalRow - this.dockPosition.row) + 
                               Math.abs(sku.originalCol - this.dockPosition.col);
        return sum + (originalDistance * sku.frequency);
    }, 0);
    
    const totalOptimizedDistance = this.skuData.reduce((sum, sku) => {
        if (sku.assignedRow >= 0 && sku.assignedCol >= 0) {
            const optimizedDistance = Math.abs(sku.assignedRow - this.dockPosition.row) + 
                                    Math.abs(sku.assignedCol - this.dockPosition.col);
            return sum + (optimizedDistance * sku.frequency);
        }
        return sum;
    }, 0);
    
    const distanceSavings = totalOriginalDistance - totalOptimizedDistance;
    const savingsPercentage = totalOriginalDistance > 0 ? 
        ((distanceSavings / totalOriginalDistance) * 100).toFixed(1) : 0;
    
    // Calculate average distances by class
    const classAAvgDist = this.calculateAverageDistanceByClass('A');
    const classBAvgDist = this.calculateAverageDistanceByClass('B');
    const classCAvgDist = this.calculateAverageDistanceByClass('C');
    
    stats.innerHTML = `
        <div class="stat-item"><span>Distance Savings:</span><span>${distanceSavings.toLocaleString()} units</span></div>
        <div class="stat-item"><span>Efficiency Gain:</span><span>${savingsPercentage}%</span></div>
        <div class="stat-item"><span>Class A Avg Distance:</span><span>${classAAvgDist.toFixed(1)}</span></div>
        <div class="stat-item"><span>Class B Avg Distance:</span><span>${classBAvgDist.toFixed(1)}</span></div>
        <div class="stat-item"><span>Class C Avg Distance:</span><span>${classCAvgDist.toFixed(1)}</span></div>
        <div class="stat-item"><span>Strategy Used:</span><span>${this.strategy.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())}</span></div>
    `;
}

// Also add this helper method
calculateAverageDistanceByClass(className) {
    const classItems = this.skuData.filter(sku => sku.abcClass === className && sku.assignedRow >= 0);
    if (classItems.length === 0) return 0;
    
    const totalDistance = classItems.reduce((sum, sku) => {
        return sum + Math.abs(sku.assignedRow - this.dockPosition.row) + 
               Math.abs(sku.assignedCol - this.dockPosition.col);
    }, 0);
    
    return totalDistance / classItems.length;
}
